"""
CRUD operations for rooms
"""
import uuid
from typing import List, Optional, Dict, Any, Tuple, Union

from app.models.room import Room, RoomParticipant, RoomProgress, RoomStatus, RoomParticipantRole
from app.schemas.room import (
    RoomCreate, RoomUpdate,
    RoomParticipantCreate, RoomParticipantUpdate,
    RoomProgressCreate, RoomProgressUpdate
)
from fastapi.encoders import jsonable_encoder
from sqlalchemy import func, or_, text, desc, asc
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select


class RoomCRUD:
    """CRUD operations for Room model"""

    @staticmethod
    async def create(db: AsyncSession, *, obj_in: Union[RoomCreate, Dict[str, Any]]) -> Room:
        """
        Create a new room
        
        Args:
            db: Database session
            obj_in: Room creation data (RoomCreate model or dict)

        Returns:
            Created room
        """
        # Convert to dict if Pydantic model
        if isinstance(obj_in, dict):
            obj_in_data = obj_in.copy()  # Create a copy to avoid modifying the original
        else:
            obj_in_data = jsonable_encoder(obj_in, exclude_unset=True)
        
        # Make sure owner_id is set before creating the room
        if not obj_in_data.get("owner_id"):
            raise ValueError("owner_id must be set before creating a room")
        
        # Ensure sensitive data is generated on the server
        from datetime import datetime, timezone
        current_time = datetime.now(timezone.utc)
        
        # Set created_at and updated_at to current time
        obj_in_data["created_at"] = current_time
        obj_in_data["updated_at"] = current_time
        
        # Code will be automatically generated by the model's default function
        if "code" in obj_in_data:
            del obj_in_data["code"]  # Remove code if provided by client
        
        db_obj = Room(**obj_in_data)
        db.add(db_obj)
        
        try:
            await db.commit()
            await db.refresh(db_obj)
            
            # Добавляем создателя как участника с ролью владельца
            participant = RoomParticipant(
                room_id=db_obj.id,
                user_id=obj_in_data["owner_id"],
                role=RoomParticipantRole.OWNER,
                joined_at=current_time,
                last_activity_at=current_time
            )
            db.add(participant)
            await db.commit()
            
            return db_obj
        except IntegrityError as e:
            await db.rollback()
            raise e

    @staticmethod
    async def get(db: AsyncSession, room_id: uuid.UUID) -> Optional[Room]:
        """
        Get a room by ID
        
        Args:
            db: Database session
            room_id: Room ID

        Returns:
            Room if found, None otherwise
        """
        query = select(Room).where(Room.id == room_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()

    @staticmethod
    async def get_by_code(db: AsyncSession, code: str) -> Optional[Room]:
        """
        Get a room by join code
        
        Args:
            db: Database session
            code: Room join code

        Returns:
            Room if found, None otherwise
        """
        query = select(Room).where(Room.code == code)
        result = await db.execute(query)
        return result.scalar_one_or_none()

    @staticmethod
    async def get_multi(
            db: AsyncSession,
            *,
            skip: int = 0,
            limit: int = 100,
            filters: Optional[Dict[str, Any]] = None,
            sort_by: str = "created_at",
            sort_order: str = "desc"
    ) -> Tuple[List[Room], int]:
        """
        Get multiple rooms with optional filtering and sorting
        
        Args:
            db: Database session
            skip: Number of records to skip
            limit: Maximum number of records to return
            filters: Optional filters
            sort_by: Field to sort by
            sort_order: Sort order ('asc' or 'desc')

        Returns:
            Tuple of (list of rooms, total count)
        """
        query = select(Room)

        # Apply filters if provided
        if filters:
            if "owner_id" in filters and filters["owner_id"]:
                query = query.where(Room.owner_id == filters["owner_id"])

            if "course_id" in filters and filters["course_id"]:
                query = query.where(Room.course_id == filters["course_id"])

            if "status" in filters and filters["status"]:
                query = query.where(Room.status == filters["status"])

            if "search" in filters and filters["search"]:
                search_term = f"%{filters['search']}%"
                language = filters.get("language", "en")

                # Search in name and description based on language
                name_field = f"name->'{language}'"
                desc_field = f"description->'{language}'"

                query = query.where(
                    or_(
                        text(f"{name_field}::text ILIKE :search"),
                        text(f"{desc_field}::text ILIKE :search")
                    )
                ).params(search=search_term)

        # Create count query before applying pagination
        count_query = select(func.count()).select_from(query.subquery())

        # Apply sorting
        if sort_order.lower() == "desc":
            query = query.order_by(desc(getattr(Room, sort_by)))
        else:
            query = query.order_by(asc(getattr(Room, sort_by)))

        # Apply pagination
        query = query.offset(skip).limit(limit)

        # Execute queries
        result = await db.execute(query)
        count_result = await db.execute(count_query)

        total = count_result.scalar_one()
        rooms = result.scalars().all()

        return rooms, total

    @staticmethod
    async def update(
            db: AsyncSession,
            *,
            db_obj: Room,
            obj_in: RoomUpdate
    ) -> Room:
        """
        Update a room
        
        Args:
            db: Database session
            db_obj: Existing room object
            obj_in: Room update data

        Returns:
            Updated room
        """
        obj_data = jsonable_encoder(db_obj)
        
        # Convert update data to dict
        if isinstance(obj_in, dict):
            update_data = obj_in.copy()
        else:
            update_data = obj_in.dict(exclude_unset=True)
        
        # Список полей, которые нельзя изменять через API
        protected_fields = ["id", "code", "owner_id", "created_at"]
        
        # Удаляем защищенные поля из данных обновления
        for field in protected_fields:
            if field in update_data:
                update_data.pop(field)
        
        # Всегда обновляем updated_at на текущее время
        from datetime import datetime, timezone
        update_data["updated_at"] = datetime.now(timezone.utc)
        
        # Обновляем все разрешенные поля
        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])
        
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    @staticmethod
    async def delete(db: AsyncSession, *, room_id: uuid.UUID) -> Optional[Room]:
        """
        Delete a room
        
        Args:
            db: Database session
            room_id: Room ID

        Returns:
            Deleted room if found and deleted, None otherwise
        """
        obj = await RoomCRUD.get(db, room_id)
        if obj:
            await db.delete(obj)
            await db.commit()
        return obj


class RoomParticipantCRUD:
    """CRUD operations for RoomParticipant model"""

    @staticmethod
    async def create(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            obj_in: RoomParticipantCreate
    ) -> Optional[RoomParticipant]:
        """
        Add a participant to a room
        
        Args:
            db: Database session
            room_id: Room ID
            obj_in: Participant data

        Returns:
            Created participant if successful, None otherwise
        """
        obj_in_data = jsonable_encoder(obj_in, exclude_unset=True)
        db_obj = RoomParticipant(room_id=room_id, **obj_in_data)

        try:
            db.add(db_obj)
            await db.commit()
            await db.refresh(db_obj)
            return db_obj
        except IntegrityError:
            await db.rollback()
            return None

    @staticmethod
    async def get(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            user_id: uuid.UUID
    ) -> Optional[RoomParticipant]:
        """
        Get a participant by room ID and user ID
        
        Args:
            db: Database session
            room_id: Room ID
            user_id: User ID

        Returns:
            Participant if found, None otherwise
        """
        query = select(RoomParticipant).where(
            RoomParticipant.room_id == room_id,
            RoomParticipant.user_id == user_id
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    @staticmethod
    async def get_room_participants(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            skip: int = 0,
            limit: int = 100
    ) -> Tuple[List[RoomParticipant], int]:
        """
        Get all participants in a room
        
        Args:
            db: Database session
            room_id: Room ID
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            Tuple of (list of participants, total count)
        """
        query = select(RoomParticipant).where(RoomParticipant.room_id == room_id)
        count_query = select(func.count()).select_from(query.subquery())

        query = query.order_by(RoomParticipant.joined_at)
        query = query.offset(skip).limit(limit)

        result = await db.execute(query)
        count_result = await db.execute(count_query)

        total = count_result.scalar_one()
        participants = result.scalars().all()

        return participants, total

    @staticmethod
    async def get_user_rooms(
            db: AsyncSession,
            *,
            user_id: uuid.UUID,
            skip: int = 0,
            limit: int = 100,
            status: Optional[RoomStatus] = None
    ) -> Tuple[List[Room], int]:
        """
        Get all rooms a user is participating in
        
        Args:
            db: Database session
            user_id: User ID
            skip: Number of records to skip
            limit: Maximum number of records to return
            status: Optional room status filter

        Returns:
            Tuple of (list of rooms, total count)
        """
        # Construct query to get rooms the user participates in
        query = select(Room).join(
            RoomParticipant,
            RoomParticipant.room_id == Room.id
        ).where(
            RoomParticipant.user_id == user_id
        )

        # Apply status filter if provided
        if status:
            query = query.where(Room.status == status)

        # Create count query
        count_query = select(func.count()).select_from(query.subquery())

        # Apply sorting and pagination
        query = query.order_by(desc(Room.created_at))
        query = query.offset(skip).limit(limit)

        # Execute queries
        result = await db.execute(query)
        count_result = await db.execute(count_query)

        total = count_result.scalar_one()
        rooms = result.scalars().all()

        return rooms, total

    @staticmethod
    async def update(
            db: AsyncSession,
            *,
            db_obj: RoomParticipant,
            obj_in: RoomParticipantUpdate
    ) -> RoomParticipant:
        """
        Update a participant
        
        Args:
            db: Database session
            db_obj: Existing participant object
            obj_in: Participant update data

        Returns:
            Updated participant
        """
        obj_data = jsonable_encoder(db_obj)
        update_data = obj_in.dict(exclude_unset=True)

        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])

        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    @staticmethod
    async def delete(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            user_id: uuid.UUID
    ) -> Optional[RoomParticipant]:
        """
        Remove a participant from a room
        
        Args:
            db: Database session
            room_id: Room ID
            user_id: User ID

        Returns:
            Deleted participant if found and deleted, None otherwise
        """
        obj = await RoomParticipantCRUD.get(db, room_id=room_id, user_id=user_id)
        if obj:
            await db.delete(obj)
            await db.commit()
        return obj


class RoomProgressCRUD:
    """CRUD operations for RoomProgress model"""

    @staticmethod
    async def create(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            obj_in: RoomProgressCreate
    ) -> RoomProgress:
        """
        Create a new progress record
        
        Args:
            db: Database session
            room_id: Room ID
            obj_in: Progress creation data

        Returns:
            Created progress record
        """
        obj_in_data = jsonable_encoder(obj_in, exclude_unset=True)
        db_obj = RoomProgress(room_id=room_id, **obj_in_data)

        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    @staticmethod
    async def get(
            db: AsyncSession,
            *,
            progress_id: uuid.UUID
    ) -> Optional[RoomProgress]:
        """
        Get a progress record by ID
        
        Args:
            db: Database session
            progress_id: Progress record ID

        Returns:
            Progress record if found, None otherwise
        """
        query = select(RoomProgress).where(RoomProgress.id == progress_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()

    @staticmethod
    async def get_by_node(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            user_id: uuid.UUID,
            node_id: str
    ) -> Optional[RoomProgress]:
        """
        Get a progress record by room ID, user ID, and node ID
        
        Args:
            db: Database session
            room_id: Room ID
            user_id: User ID
            node_id: Node ID

        Returns:
            Progress record if found, None otherwise
        """
        query = select(RoomProgress).where(
            RoomProgress.room_id == room_id,
            RoomProgress.user_id == user_id,
            RoomProgress.node_id == node_id
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    @staticmethod
    async def get_user_progress(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            user_id: uuid.UUID
    ) -> List[RoomProgress]:
        """
        Get all progress records for a user in a room
        
        Args:
            db: Database session
            room_id: Room ID
            user_id: User ID

        Returns:
            List of progress records
        """
        query = select(RoomProgress).where(
            RoomProgress.room_id == room_id,
            RoomProgress.user_id == user_id
        )
        result = await db.execute(query)
        return result.scalars().all()

    @staticmethod
    async def get_node_progress(
            db: AsyncSession,
            *,
            room_id: uuid.UUID,
            node_id: str
    ) -> List[RoomProgress]:
        """
        Get all progress records for a node in a room
        
        Args:
            db: Database session
            room_id: Room ID
            node_id: Node ID

        Returns:
            List of progress records
        """
        query = select(RoomProgress).where(
            RoomProgress.room_id == room_id,
            RoomProgress.node_id == node_id
        )
        result = await db.execute(query)
        return result.scalars().all()

    @staticmethod
    async def update(
            db: AsyncSession,
            *,
            db_obj: RoomProgress,
            obj_in: RoomProgressUpdate
    ) -> RoomProgress:
        """
        Update a progress record
        
        Args:
            db: Database session
            db_obj: Existing progress record
            obj_in: Progress update data

        Returns:
            Updated progress record
        """
        obj_data = jsonable_encoder(db_obj)
        update_data = obj_in.dict(exclude_unset=True)

        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])

        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    @staticmethod
    async def delete(
            db: AsyncSession,
            *,
            progress_id: uuid.UUID
    ) -> Optional[RoomProgress]:
        """
        Delete a progress record
        
        Args:
            db: Database session
            progress_id: Progress record ID

        Returns:
            Deleted progress record if found and deleted, None otherwise
        """
        obj = await RoomProgressCRUD.get(db, progress_id=progress_id)
        if obj:
            await db.delete(obj)
            await db.commit()
        return obj
