# Модуль утилит

Этот модуль предоставляет различные служебные классы и функции, используемые во всем приложении CompEduX.

## NavigationExecutor

`NavigationExecutor` — это утилитарный класс, разработанный для решения проблем с потоками при работе с навигацией Decompose. Он гарантирует, что все операции навигации выполняются в главном потоке, и обеспечивает обработку ошибок и ведение журнала.

### Ключевые особенности

- Безопасное выполнение операций навигации
- Потокобезопасная навигация между экранами
- Обработка ошибок для операций навигации
- Асинхронное выполнение фоновых операций с последующей навигацией
- Журналирование операций навигации и ошибок

### Использование

```kotlin
// Создание NavigationExecutor
val navigationExecutor = NavigationExecutor(
    navigation = navigation,
    scope = coroutineScope(rDispatchers.main),
    mainDispatcher = rDispatchers.main,
    logger = { message -> Logger("Navigation").i(message) }
)

// Переход на экран
navigationExecutor.navigateTo(Config.Home)

// Добавление нового экрана в стек
navigationExecutor.push(Config.Details)

// Навигация назад
navigationExecutor.pop()

// Выполнение фоновой операции и последующая навигация
navigationExecutor.executeAsync(
    backgroundOperation = { repository.fetchData() },
    onSuccess = { data ->
        // Навигация на основе результата
        navigationExecutor.navigateTo(Config.DataView)
    }
)
```

### Безопасность потоков

`NavigationExecutor` обеспечивает безопасность потоков следующим образом:

1. **Синхронное выполнение**: Операции навигации выполняются синхронно в вызывающем потоке
2. **Корутины, привязанные к жизненному циклу**: Использует области корутин, привязанные к жизненным циклам компонентов
3. **Переключение потоков**: Гарантирует, что фоновые операции выполняются в IO-потоках, а операции UI — в главном потоке
4. **Обработка ошибок**: Перехватывает и регистрирует все исключения, связанные с навигацией

## RDispatchers

Интерфейс `RDispatchers` предоставляет специфичные для платформы диспетчеры для корутин:

- **main**: Диспетчер для операций UI, эквивалент Dispatchers.Main
- **io**: Диспетчер для операций ввода-вывода, эквивалент Dispatchers.IO
- **default**: Диспетчер для интенсивных операций ЦП, эквивалент Dispatchers.Default
- **unconfined**: Диспетчер без ограничений потока, эквивалент Dispatchers.Unconfined

### Реализации для разных платформ

Интерфейс имеет различные реализации для каждой платформы:

- **Android**: Использует MainThreadDispatcher для операций UI
- **JVM**: Использует Dispatchers.Main, настроенный с диспетчером Swing
- **iOS**: Использует специфичные для платформы диспетчеры
- **Web**: Использует соответствующие веб-специфичные диспетчеры

## Лучшие практики

При работе с этими утилитами следуйте этим лучшим практикам:

1. Всегда используйте `NavigationExecutor` для операций навигации в компонентах
2. Привязывайте области корутин к жизненным циклам компонентов, используя `coroutineScope` из Essenty
3. Используйте `rDispatchers.io` для фоновых операций и `rDispatchers.main` для обновлений UI
4. Убедитесь, что все операции навигации исходят из главного потока
5. Правильно обрабатывайте ошибки как в навигации, так и в асинхронных операциях

## Проблемы, связанные с потоками

Если вы сталкиваетесь с `NotOnMainThreadException` или подобными проблемами с потоками:

1. Убедитесь, что все операции навигации выполняются в главном потоке
2. Проверьте, что `rDispatchers.main` правильно настроен для платформы
3. Убедитесь, что области корутин правильно созданы и привязаны к жизненным циклам компонентов
4. Рассмотрите возможность использования синхронных методов навигации `NavigationExecutor` непосредственно из обработчиков событий UI
